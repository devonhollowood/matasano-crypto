use aes;

use rand;

pub struct Oracle {
    key: [u8; 16],
    iv: [u8; 16],
}

impl Oracle {
    pub fn new() -> Oracle {
        Oracle {
            key: random_block(),
            iv: random_block()
        }
    }
    #[cfg(test)]
    pub fn controlled(key : &[u8; 16], iv: &[u8; 16]) -> Oracle {
        Oracle { key: key.clone(), iv: iv.clone() }
    }
    pub fn encrypt(&self, message: &str) -> Vec<u8> {
        let prefix = "comment1=cooking%20MCs;userdata=";
        let message = message.replace("=", "%3D").replace(";", "%3B");
        let suffix = ";comment2=%20like%20a%20pound%20of%20bacon";
        let text: Vec<u8> =
            prefix.bytes().chain(message.bytes()).chain(suffix.bytes()).collect();
        aes::aes_cbc_encrypt(&text[..], &self.key, &self.iv)
    }
    pub fn is_admin(&self, ciphertext: &[u8]) -> bool {
        if let Ok(decoded) = aes::aes_cbc_decrypt(&ciphertext, &self.key, &self.iv){
            contains(&decoded, "user=admin".as_bytes())
        }
        else {
            false
        }
    }
}
fn random_block() -> [u8; 16] {
    use rand::Rng;
    let mut rng = rand::thread_rng();
    let mut block = [0u8; 16];
    for el in block.iter_mut() {
        *el = rng.gen::<u8>();
    }
    block
}

fn contains(container: &[u8], containee:  &[u8]) -> bool {
    for idx in 0..(container.len()-containee.len()) {
        if container[idx..].starts_with(containee) {
            return true;
        }
    }
    false
}

#[cfg(test)]
mod tests {
    use super::Oracle;

    #[test]
    fn empty_encrypt() {
        let key = [0x79, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x20, 0x73, 0x75, 0x62,
                   0x6d, 0x61, 0x72, 0x69, 0x6e, 0x65]; //"yellow submarine"
        let iv  = [0x74, 0x68, 0x65, 0x20, 0x31, 0x73, 0x74, 0x20, 0x31, 0x36,
                   0x20, 0x62, 0x79, 0x74, 0x65, 0x73]; //"the 1st 16 bytes"
        let oracle = Oracle::controlled(&key, &iv);
        let output = oracle.encrypt("");
        let expected = vec![0x5f, 0x42, 0xc3, 0xdd, 0x32, 0xfe, 0x04, 0x86, 0x21,
                            0xc0, 0xea, 0xc1, 0x96, 0xbd, 0x01, 0xe4, 0x79, 0xdb,
                            0x1c, 0x4d, 0xd9, 0x78, 0x9a, 0x41, 0xac, 0xfd, 0x0a,
                            0xeb, 0xac, 0x3b, 0x47, 0x7a, 0xd1, 0x3d, 0x92, 0x2b,
                            0x40, 0x8a, 0x39, 0xd0, 0x34, 0xf9, 0x9e, 0x5b, 0x18,
                            0x3a, 0xbe, 0x51, 0x64, 0x6f, 0x21, 0x90, 0xc1, 0x64,
                            0x6b, 0xbe, 0x8a, 0x16, 0x2b, 0x41, 0x1c, 0x35, 0x02,
                            0x74, 0xd8, 0xcc, 0xaf, 0xd9, 0x57, 0xec, 0xd6, 0x46,
                            0x0c, 0x5d, 0x6f, 0xed, 0x04, 0x07, 0x40, 0x2b];
        assert_eq!(output, expected);
    }

    #[test]
    fn encrypt() {
        let key = [0x79, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x20, 0x73, 0x75, 0x62,
                   0x6d, 0x61, 0x72, 0x69, 0x6e, 0x65]; //"yellow submarine"
        let iv  = [0x74, 0x68, 0x65, 0x20, 0x31, 0x73, 0x74, 0x20, 0x31, 0x36,
                   0x20, 0x62, 0x79, 0x74, 0x65, 0x73]; //"the 1st 16 bytes"
        let oracle = Oracle::controlled(&key, &iv);
        let output = oracle.encrypt("hello world");
        let expected = vec![0x5f, 0x42, 0xc3, 0xdd, 0x32, 0xfe, 0x04, 0x86, 0x21,
                            0xc0, 0xea, 0xc1, 0x96, 0xbd, 0x01, 0xe4, 0x79, 0xdb,
                            0x1c, 0x4d, 0xd9, 0x78, 0x9a, 0x41, 0xac, 0xfd, 0x0a,
                            0xeb, 0xac, 0x3b, 0x47, 0x7a, 0x76, 0xa0, 0x56, 0x48,
                            0x12, 0xd4, 0x44, 0xd1, 0x20, 0x21, 0xdd, 0xbe, 0x10,
                            0x3b, 0xd6, 0x78, 0x97, 0x1e, 0xb8, 0x8c, 0xcc, 0xba,
                            0x59, 0x89, 0xb0, 0xa1, 0x42, 0x32, 0x8f, 0xf0, 0x5b,
                            0x23, 0x0d, 0x77, 0x21, 0x8e, 0xcb, 0xdf, 0x14, 0x93,
                            0x73, 0xb5, 0x3a, 0xce, 0xa6, 0x8b, 0xf5, 0x30, 0xe5,
                            0x6b, 0xcb, 0x14, 0x8b, 0xbc, 0xa3, 0xc0, 0xbe, 0xe3,
                            0x40, 0x89, 0xc6, 0xb3, 0x9b, 0xfb];
        assert_eq!(output, expected);
    }

    use super::contains;

    #[test]
    fn contains_pass() {
        let container = vec![0,1,2,3,4];
        let containee = vec![2,3];
        assert_eq!(contains(&container[..], &containee[..]), true);
    }

    #[test]
    fn contains_fail() {
        let container = vec![0,1,2,3,4];
        let containee = vec![3,4,5];
        assert_eq!(contains(&container[..], &containee[..]), false);
    }
}
